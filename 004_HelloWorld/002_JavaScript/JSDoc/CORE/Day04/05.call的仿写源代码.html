<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // call的使用场景:
      // 函数.call(对象):  函数执行时就相当于是放在 参数对象 中执行
      // 其中的this会指向 指定的对象
      Function.prototype._call = function (obj) {
        // 此处的this 就相当于是
        // var demo = new Function("console.log(this.name)");
        // fn是自定义的属性
        obj.fn = this; //this是当前函数, 保存到了对象里
        // 对象调用函数: 函数中的this指向其所在的对象!
        obj.fn(); //函数的this 就变为了obj, 即传入的对象
      };
      // var demo = new Function('console.log(this.name)')
      function demo() {
        console.log(this.name);
      }

      var obj;
      obj = { name: "亮亮" };
      demo._call(obj);

      demo._call({ name: "铭铭" });
    </script>
  </body>
</html>

<script>
  Function.prototype._call = function (obj) {
    // demo._call(obj):  所以_call函数中的this 就是demo
    obj.fn = this;
    obj.fn();
  };

  function demo() {
    console.log(this.name);
  }

  var obj;
  obj = { name: "亮亮" };
  demo._call(obj);

  function show() {
    // 函数中的this指向函数执行时所在的对象
    console.log(this.name);
  }

  var obj1 = { name: "亚楠" };
  // 对象.属性名 = 值;  属性名不存在就会自动创建
  obj1.fn = show;
  console.log(obj1);
  obj1.fn();

  var obj1 = {
    name: "亚楠",
    // fn: function show() {
    //   console.log(this.name);
    // },
  };
  obj1.fn = function show() {
    console.log(this.name);
  };
  obj1.fn();
</script>

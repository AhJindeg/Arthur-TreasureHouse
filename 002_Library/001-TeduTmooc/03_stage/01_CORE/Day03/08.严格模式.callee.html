<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 严格模式: 淘汰了 callee
      "use strict";

      // callee: 是 arguments 中的一个属性, 保存了当前执行的函数
      function show() {
        console.log(arguments);
      }
      show(123, 23, true, "哈哈");

      // 回调函数: 函数的内部调用自身, 形成一个循环的效果
      function factorial(n) {
        if (n > 1) {
          return n * factorial(n - 1);
        }
        return 1;
      }
      //计算 5! = 1 * 2 * 3 * 4 * 5
      console.log(factorial(5)); //120

      // 匿名函数自调用
      // 在早期的JS中, 不支持命名函数的自调用, 只能是匿名函数自调用
      var result = (function (n) {
        if (n > 1) {
          // callee: 代表当前正在执行的函数, 适合匿名函数的取用
          // 递归函数多次调用, 会多次创建 arguments 对象, 浪费内存!
          return n * arguments.callee(n - 1);
        }
        return 1;
      })(5);
      console.log(result);

      // 命名函数自调用, 古老的JS版本中不支持, 所以只能用 消耗极大的 callee 实现
      // 自从有了 命名函数自调用写法, callee 就被淘汰了!
      var result = (function a(n) {
        if (n > 1) {
          // callee: 代表当前正在执行的函数, 适合匿名函数的取用
          return n * a(n - 1);
        }
        return 1;
      })(5);
    </script>
  </body>
</html>

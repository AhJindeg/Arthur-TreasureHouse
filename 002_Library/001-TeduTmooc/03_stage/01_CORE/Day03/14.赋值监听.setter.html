<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      "use strict";
      // 赋值监听
      var yanan = {
        name: "亚楠",
        age: 19,
      };
      //要求: 亚楠的年龄范围是: 1~100 , 超过就要报错

      // 生成一个额外的变量, 来保存age的值, 防止下方的无限循环
      var __age; //__没有特殊作用, 习惯上把这种专门负责保存 set 方法设定的属性值的额外属性, 加__ 前缀, 以示特殊!

      Object.defineProperty(yanan, "age", {
        // 赋值,设置值: set
        set: function (value) {
          console.log("有新的年龄传入:", value);
          // 判断: 1-100 就正常赋值, 否则就报错!
          if (value >= 1 && value <= 100) {
            // __age 是var声明的, 不用加this, 属于普通作用域

            __age = value; //赋值, 会触发 age 的set方法
          } else {
            throw Error("年龄范围错误: " + value);
          }
        },
        // 读取时 返回 __age 的值,  这个变量的值是 set 设置的
        get: function () {
          return __age;
        },
      });

      yanan.age = 50; //应该报错!
      console.log(yanan);
      console.log(yanan.age); //触发get

      // 匿名函数自调用, 就可以形成一个 闭包作用域
      // set 和 get 方法都存储在 yanan里, yanan 在window里, 所以大家都是活的
      (function () {
        var __salary;

        Object.defineProperty(yanan, "salary", {
          get: function () {
            return __salary;
          },
          set: function (value) {
            if (value >= 1000 && value <= 100000) {
              __salary = value;
            } else {
              throw Error("薪资范围错误" + value);
            }
          },
        });
      })();

      // yanan.salary = 250; //会报错
      yanan.salary = 11250; //正常
      console.log(yanan.salary);
    </script>
  </body>
</html>

<!-- 
  set: 用来监听属性的赋值
  为什么? 防止一些明显错误的值的添加!
  如何做? 
    修改属性的 set, 在此方法中接受赋值, 然后对值进行检测, 如果正确才赋值-- 此处不能给当前属性赋值, 会无限循环 -- 此处必须额外声明一个变量, 来存储值

    读取时, 再通过 get 方法, 来返回那个存值的变量
 -->

<!-- 
   练习: 增加一个薪资属性 salary
   此属性的取值范围 1000~100000

   如果赋值错误, 就抛出错误, 否则正常赋值
-->
